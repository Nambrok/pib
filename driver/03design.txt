・ロックの優先順位

  dev → qp → srq → pd → cq

  mad.c の中で ib_post_send の外側で spin_lock_irqsave している。
  セマフォではなく spin_lock を使う必要がある。

	spin_lock_irqsave(&qp_info->send_queue.lock, flags);
	if (qp_info->send_queue.count < qp_info->send_queue.max_active) {
		ret = ib_post_send(mad_agent->qp, &mad_send_wr->send_wr,
				   &bad_send_wr);
		list = &qp_info->send_queue.list;
	} else {
		ret = 0;
		list = &qp_info->overflow_list;
	}

	if (!ret) {
		qp_info->send_queue.count++;
		list_add_tail(&mad_send_wr->mad_list.list, list);
	}
	spin_unlock_irqrestore(&qp_info->send_queue.lock, flags);

・スラブを使うのを止める

・MR

  MR の L_Key と R_Key は PD に設けられた mr_table[] のインデックス値とする。
  ただし配列のインデックスとして使うのは下位ビットで、上位ビットは PD ごと
  に設定する乱数値とする。

・GID

  イーサネットの MAC アドレス(48 bit)をベースに生成する

  0x0000 Not use
  0x0100 Easy Switch
  0x0200 SystemImageGUID 
  0xaabb NodeGUID or PortGUID
         -- aa は 3 から始まる HCA 番号
         -- bb は 0 なら NodeGUID で、1 以上は PortGUID
 

・輻輳制御


・送信処理は Send WR を submitted(未送信)、sending(送信中)、waiting(ACK待ち) の 3 つのキューで処理する。

  - Send Drain(SQD) 属性になった場合は、submitted キューにあるのものは送信しない。
  - 1回分の送信が完了すれば sending キューのエントリは waiting キューに送る。
  - 送信が失敗(NAK受信など)になると wainting キューにある全エントリは sending キューに戻した上で、
    全ての未 ACK パケット分をクリアする。

  - ACK は sending キューと waiting キューにある場合の二通りが考えられる。

  - UD with SRQ で responder 側に length error が起きても Aborted Error Completion は発生させない。
    May casuse Aborted Error completion


 
  
